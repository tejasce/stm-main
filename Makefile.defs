#
# @file: Makefile that defines absolute paths and macro definitions for
#        the build system for the repo. It is included at each directory
#        level of this repo to allow invoking and building at any
#        sub-directory level.
#


#
# Use temporary variable to represent TOPDIR since this file maybe
# included from anywhere in the directory tree. Since value of
# TOPDIR is used to determine where this file was included from,
# it may or may not be set. And paths of these makefiles must
# always resolve.
#
_TOPDIR_ := $(shell git rev-parse --show-toplevel)
Makefile.buildenv := $(_TOPDIR_)/build/Makefile.buildenv
Makefile.cargo := $(_TOPDIR_)/build/Makefile.cargo
Makefile.cbin := $(_TOPDIR_)/build/Makefile.cbin
Makefile.clib := $(_TOPDIR_)/build/Makefile.clib
Makefile.protobuf := $(_TOPDIR_)/build/Makefile.protobuf
Makefile.ros := $(_TOPDIR_)/build/Makefile.ros
Makefile.stm32 := $(_TOPDIR_)/build/Makefile.stm32
Makefile.toolchain := $(_TOPDIR_)/build/Makefile.toolchain
Makefile.zephyr := $(_TOPDIR_)/build/Makefile.zephyr

#
# Common constants
#
CORES := $(shell nproc 2>/dev/null || echo 1)
DEPFLAGS = -MT $@ -MMD -MP -MF $*.Td
STM32_CFLAGS := -mcpu=cortex-m4 -mlittle-endian -mthumb -Os -ggdb
# Supported C++ source and header extensions. Excludes .c because
# that's what distinguishes a C file from C++ file
CC_EXTS := .cpp .cc
CC_H_EXTS := .hpp .h .hh
CC_EXTS_PATT := $(CC_EXTS:%=\%%)
CC_H_EXTS_PATT := $(CC_H_EXTS:%=\%%)
# PROTOBUF ARCH dependent CFLAGS and LFLAGS
PROTOBUF_CFLAGS := -pthread -I/usr/local/$(ARCH)/include
PROTOBUF_LFLAGS := -L/usr/local/$(ARCH)/lib -lprotobuf -lpthread
# Number of colums to print at start of line in build output
PCOL := 10

#
# All supported rules
#
ALL_RULES := STM32_ELF C_LIB C_BIN PROTO_LIB ZEPHYR_APP CARGO_PROJ

#
# Enumerate name of attributes for each rule to undef them before inclusion
# of Makefile.<rule> for proper init state for the new "PRODUCT"
#
COMMON_ATTRS := PRODUCT
COMMON_C_ATTRS := CFLAGS CXXFLAGS LFLAGS H_DIRS C_SRCS DEPEND
STM32_ELF_ATTRS := S_SRCS LD_SRC $(COMMON_C_ATTRS)
C_LIB_ATTRS := I_HDRS STRIP_INC_PREFIX INC_PREFIX $(COMMON_C_ATTRS)
C_BIN_ATTRS := $(COMMON_C_ATTRS)
PROTO_LIB_ATTRS := PB_SRCS DEPEND
ZEPHYR_APP_ATTRS := BOARD ZEPHYR_TOOLCHAIN_ARGS
CARGO_PROJ_ATTRS :=
ALL_ATTRS := $(sort $(foreach rule,$(ALL_RULES),$($(rule)_ATTRS))) $(COMMON_ATTRS)


#
# Import toolchain include macro
#
include $(Makefile.toolchain)


#
# Helper command line variable for build debugging
#
ifdef VERBOSE
Q :=
else
Q := @
endif


#
# Macro to include a sub-directory
#
define subdirs
PRODIR := $(1)
OBJDIR := $(OBJDIR_PREFIX)$(ARCH)

#
# Set toolchain for the subdir and the ones below it. This can be overridden by
# each individual directory
#
$$(eval $$(call inc_toolchain,$$(ARCH)))

#
# Variables representing supported product build rules. Reset for the subdir
#
$$(foreach RULE,$(ALL_RULES),$$(eval $$(RULE) := ))

#
# Clean the slate: reset attributes for all rules
#
$$(foreach ATTR,$(ALL_ATTRS),$$(eval $$(ATTR) := ))

#
# While we are here, define ease-of-use target for this directory
#
DIR_TGT := $$(PRODIR) $$(PRODIR)/
.PHONY: $$(DIR_TGT)
$$(DIR_TGT):
	$(Q)$$(MAKE) --no-print-directory -C $$@ $$(if $$(clean),clean,)

include $(1)/Makefile
endef


#
# Wrapper macro to "subdirs" macro. Depending upon which directory "$(MAKE)"
# is invoked upon, this macro will either simply include subdirectories or
# recursively find all the "Makefile" from directories below and include them.
#
define inc_subdir
ifeq ($(TOPDIR),)
# This method won't honor if a subdir is present but isn't
# enlisted in the makefile of the parent dir
MKFILES += $(shell find $(1) -mindepth 2 -name Makefile)

#
# Accumulated makefiles need to be included only once;
# use sort to enumuerate unique ones.
#
ifndef INC_MAKEFILE
INC_MAKEFILE := 1
$$(foreach makefile,$$(sort $$(MKFILES)),$$(eval include $$(makefile)))
endif

else
$$(foreach SUBDIR,$(2:%=$(1)%),$$(eval $$(call subdirs,$$(SUBDIR))))
endif
endef


#
# Wrapper macro to include "Makefile.<rule>".
#
define inc_rule
ifeq ($(TOPDIR),)

#
# inc_rule() may be called more than once in a Makefile and each
# time, we accumulate goals to be built by updating TARGETS
#
ifeq ($(MAKECMDGOALS),)
TARGETS += all.$(2)
else
TARGETS += $(MAKECMDGOALS:%=%.$(2))
endif

#
# o $$(TARGETS) needs to be defined only once.
# o $$(TARGETS) is used in the definition since $$@
#   expansion covers only the first target.
#
ifndef DEF_TARGETS
DEF_TARGETS := 1

$(MAKECMDGOALS): $$(TARGETS)
$$(TARGETS):
	$(Q)$$(MAKE) -C $$(_TOPDIR_) --no-print-directory $$(TARGETS)
endif

else
#
# While we are here, define ease-of-use target for this product
#
$(PRODIR)\:$(2): $(if $(clean),clean.$(2),all.$(2))

include $(Makefile.$(1))
endif

#
# Clean the slate: reset attributes for all rules
#
$$(foreach ATTR,$(ALL_ATTRS),$$(eval $$(ATTR) := ))

#
# Reset back to original toolchain
#
$$(eval $$(call inc_toolchain,$$(ARCH)))
endef


#
# Macro specifying rules to build an individual C/C++ object target and wrapper macro
# that accepts multiple C/C++ source files and calls the worker macro
#
define C_OBJ_TGT

SUFFIX := $$(suffix $(1))

ifeq ($$(SUFFIX),$$(filter $$(SUFFIX),$$(CC_EXTS)))
GCC := $$(CXX)
GCCSTR := "[CXX]"
else ifeq ($$(SUFFIX),.c)
GCC := $$(CC)
GCCSTR := "[CC]"
# Ignore CXXFLAGS for .c files
CXXFLAGS :=
else
$$(error ERROR: Invalid C/C++ suffix '$(1)' (Supported: .c $$(CC_EXTS)))
endif

# Remove $(OBJDIR) prefix from "SRCFILE" (aka $(1)) [in case if it's a generated one]
# before adding it as a prefix to "OBJFILE"
OBJFILE := $(OBJDIR)/$$(patsubst %$$(SUFFIX),%.o,$(subst $(OBJDIR)/,,$(1)))

$$(OBJFILE):: GCCSTR := $$(GCCSTR)
$$(OBJFILE):: GCC := $$(GCC)
$$(OBJFILE):: CFLAGS := $$(CFLAGS)
$$(OBJFILE):: CXXFLAGS := $$(CXXFLAGS)
$$(OBJFILE): $(1) | $$(dir $$(OBJFILE))
	@printf "%$(PCOL)s %s\n" $$(GCCSTR) $$@
	$(Q)$$(GCC) $$(CFLAGS) $$(CXXFLAGS) $$(DEPFLAGS) -c $$< -o $$@
	@mv -f $$*.Td $$*.d && touch $$@

include $$(wildcard $$(patsubst %,%.d,$$(basename $$(OBJFILE))))
endef
define add_c_obj_tgts
$$(foreach SRCFILE,$(1),$$(eval $$(call C_OBJ_TGT,$$(SRCFILE))))
endef


#
# Evaluate depency targets, CFLAGS and LFLAGS for deps as specified by $(DEPEND).
# This is common eval between Makefile.{cbin,clib,stm32}.
#  [in] - $(DEPEND), $(OBJDIR)
# [out] - Dependency target names: $(DEP_SO) $(DEP_AR)
#         Dependency CFLAGS: $(DEPINC)
#         Dependency LFLAGS: $(DEP_LD)
#
define eval_clib_deps
DEPDIR := $$(foreach dep,$$(DEPEND),$$(firstword $$(subst :, ,$$(dep))))
DEPTGT := $$(foreach dep,$$(DEPEND),$$(lastword $$(subst :, ,$$(dep))))
DEP_SO := $$(foreach dep,$$(DEPEND),$$(patsubst %,$$(OBJDIR)/%.so,$$(subst :,/lib,$$(dep))))
DEP_AR := $$(DEP_SO:%.so=%.a)
DEPINC := $$(DEPDIR:%=-I$$(OBJDIR)/%)
DEP_LD := $$(DEPDIR:%=-L$$(OBJDIR)/%)
DEP_LD += $$(DEPTGT:%=-l:lib%.a)
endef


#
# Macro to create target that's invoked if "cflags" of a product is changed from
# previous build. It is also added as dependency on the "c-objects" of the product.
#  [in] - "product name $(1)", $(PRODUCT_OBJDIR), $(CFLAGS), $(LFLAGS), $(CXXFLAGS)
# [out] - Dependency target that detects changes in "cflags" and forces rebuild
#         of "c-objects" of the product
#
define cflags_change_tgt
# List of flags to detect change in
DIFF_FLAGS := CFLAGS LFLAGS CXXFLAGS

METADATA_FILE := $(PRODUCT_OBJDIR)/metadata.$(1).mk
METADATA_FILE_TMP := $$(METADATA_FILE:%=%.tmp)

$$(METADATA_FILE):: CFLAGS := $(CFLAGS)
$$(METADATA_FILE):: LFLAGS := $(LFLAGS)
$$(METADATA_FILE):: CXXFLAGS := $(CXXFLAGS)
$$(METADATA_FILE):: METADATA_FILE_TMP := $$(METADATA_FILE_TMP)
$$(METADATA_FILE): clean_$$(METADATA_FILE_TMP) | $(PRODUCT_OBJDIR)
	$$(foreach flag,$$(DIFF_FLAGS),$$(shell eval "echo $$(flag) := $$($$(flag)) >> $$(METADATA_FILE_TMP)"))
	@if [ ! -f $$@ ] || ! diff $$@ $$(METADATA_FILE_TMP) >/dev/null; then \
		[ -f $$@ ] && printf "%$(PCOL)s %s\n" "[=>]" "$$(@D)/$(1) [flags changed]"; \
		mv $$(METADATA_FILE_TMP) $$@; \
	else \
		rm $$(METADATA_FILE_TMP); \
	fi

clean_$$(METADATA_FILE_TMP):: METADATA_FILE_TMP := $$(METADATA_FILE_TMP)
clean_$$(METADATA_FILE_TMP):
	@rm -f $$(METADATA_FILE_TMP)

$(C_OBJS): $$(METADATA_FILE)
endef
