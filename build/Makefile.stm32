ifdef STM32_ELF

# Override to use arm-none-eabi-gcc and, consequently, $(OBJDIR) location
include $(Makefile.firmware)
OBJDIR := $(OBJDIR_PREFIX)firmware

# This file defines rules for targets: [all|clean].$(PRODUCT)
PRODUCT := $(STM32_ELF)
# For top Makefile
PRODUCTS += $(PRODUCT)
PRODUCT_OBJDIR := $(OBJDIR)/$(PRODIR)

ELF := $(PRODUCT_OBJDIR)/$(STM32_ELF).elf
BIN := $(ELF:%.elf=%.bin)
HEX := $(ELF:%.elf=%.hex)
LD_MAP := $(ELF:%.elf=%.map)

H_INCS := $(H_DIRS:%=-I$(PRODIR)/%)
C_OBJS := $(C_SRCS:%.c=$(OBJDIR)/$(PRODIR)/%.o)
S_OBJS := $(S_SRCS:%.s=$(OBJDIR)/$(PRODIR)/%.o)
LD_SRC := $(LD_SRC:%=$(PRODIR)/%)

# For top Makefile
OBJ_SUBDIRS += $(sort $(dir $(C_OBJS) $(S_OBJS)))

CFLAGS += -Wall -mcpu=cortex-m4 -mlittle-endian -mthumb -Os -ggdb
CFLAGS += $(H_INCS)
CFLAGS += -DSTM32F401xE
LFLAGS += -Wl,--gc-sections -Wl,-n,--print-map,--cref,-Map,$(LD_MAP)

# Add targets for each .o file
$(eval $(call add_c_obj_tgts,$(C_OBJS)))

define S_OBJ_TGT
$(1): $(subst $(OBJDIR)/,,$(1:%.o=%.s)) | $(dir $(1))
	@if [ "$(VERBOSE)" ]; then \
		echo "Building $$< => $$@"; \
	fi;
	$(Q)$$(CC) $$(CFLAGS) -c $$< -o $$@
endef
$(foreach OBJFILE,$(S_OBJS),$(eval $(call S_OBJ_TGT,$(OBJFILE))))

$(ELF): $(LD_SRC) $(C_OBJS) $(S_OBJS)
	@echo "Creating $@"
	$(Q)$(CC) $(LFLAGS) -T $^ -o $@

$(BIN): $(ELF)
	@echo "Creating $@"
	$(Q)$(OBJCOPY) -Obinary $^ $@

$(HEX): $(ELF)
	@echo "Creating $@"
	$(Q)$(OBJCOPY) -Oihex $^ $@

all.$(PRODUCT): $(ELF) $(BIN) $(HEX)

clean.$(PRODUCT):
	@echo "Removing $(PRODUCT_OBJDIR)"
	$(Q)rm -rf $(PRODUCT_OBJDIR)

# Preserve target specific values of [applicable] variables
$(ELF):: CC := $(CC)
$(ELF):: CFLAGS := $(CFLAGS)
$(ELF):: LFLAGS := $(LFLAGS)
$(HEX) $(BIN):: OBJCOPY := $(OBJCOPY)
clean.$(PRODUCT):: PRODUCT_OBJDIR := $(PRODUCT_OBJDIR)

endif  # define STM32_ELF
